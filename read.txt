const Chat = require('../models/Chat');
 
// Create 1-to-1 or Group chat
exports.createChat = async (req, res) => {
  const { userIds, isGroup, groupName } = req.body;
  const loggedInUser = req.user._id;
 
  if (!userIds || userIds.length === 0)
    return res.status(400).json({ message: 'Members required' });
 
  // 1-to-1 chat
  if (!isGroup && userIds.length === 1) {
    let existing = await Chat.findOne({
      isGroup: false,
      members: { $all: [loggedInUser, userIds[0]], $size: 2 },
    });
    if (existing) return res.json(existing);
 
    const chat = await Chat.create({ members: [loggedInUser, userIds[0]] });
    return res.json(chat);
  }
 
  // Group chat
  const chat = await Chat.create({
    isGroup: true,
    members: [...userIds, loggedInUser],
    groupName,
    groupAdmin: loggedInUser,
  });
  res.json(chat);
};
 
 const Message = require('../models/Message');
const Chat = require('../models/Chat');
 
exports.sendMessage = async (req, res) => {
  const { chatId, content, messageType } = req.body;
  const sender = req.user._id;
 
  const message = await Message.create({
    chat: chatId,
    sender,
    content,
    messageType,
  });
 
  // Update last message in chat
  await Chat.findByIdAndUpdate(chatId, { lastMessage: message._id });
 
  res.json(message);
};
 
exports.getMessages = async (req, res) => {
  const { chatId } = req.params;
 
  const messages = await Message.find({ chat: chatId }).populate('sender', 'name');
  res.json(messages);
};
 
const jwt = require('jsonwebtoken');
const Chat = require('./models/Chat');
const Message = require('./models/Message');
 
module.exports = (io) => {
  io.use((socket, next) => {
    const token = socket.handshake.query.token;
    if (!token) return next(new Error('Authentication error'));
 
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      socket.userId = decoded.userId;
      next();
    } catch {
      next(new Error('Authentication error'));
    }
  });
 
  io.on('connection', (socket) => {
    console.log('Connected:', socket.userId);
 
    socket.on('joinChat', (chatId) => {
      socket.join(chatId);
    });
 
    socket.on('sendMessage', async ({ chatId, content, messageType }) => {
      const message = await Message.create({
        chat: chatId,
        sender: socket.userId,
        content,
        messageType,
      });
 
      await Chat.findByIdAndUpdate(chatId, { lastMessage: message._id });
 
io.to(chatId).emit('messageReceived', {
        sender: socket.userId,
        content,
        messageType,
        createdAt: message.createdAt,
      });
    });
 
    socket.on('disconnect', () => {
      console.log('Disconnected');
    });
  });
};
 
const jwt = require('jsonwebtoken');
const User = require('../models/User');
 
module.exports = async (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  if (!token) return res.status(401).json({ message: 'No token provided' });
 
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = await User.findById(decoded.userId);
    next();
  } catch (err) {
    res.status(401).json({ message: 'Invalid token' });
  }
};

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2ODE0YjZiNTRkMDRiODc4NWVhODc1MzMiLCJpYXQiOjE3NDYxODc5NjgsImV4cCI6MTc0NjI3NDM2OH0.eqcSx3HVe3f4H1MdbDYjgkotyGMYWh81raIMeq61zog

//mark ad read 

exports.markMessagesAsSeen = async (req, res) => {
  const { chatId } = req.body;
  const userId = req.user._id;
 
  try {
    // Sirf un messages ko seen karo jo:
    // - chat ke ho
    // - sender current user na ho
    // - abhi tak seen na hue ho
    await Message.updateMany(
      {
        chat: chatId,
        sender: { $ne: userId },
        status: { $ne: 'seen' }
      },
      {
        $set: { status: 'seen' }
      }
    );
 
    res.status(200).json({ message: "Marked messages as seen" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
 
 
socket.on("markAsSeen", async ({ chatId }) => {
  const userId = socket.user._id;
 
  await Message.updateMany(
    {
      chat: chatId,
      sender: { $ne: userId },
      status: { $ne: 'seen' }
    },
    {
      $set: { status: 'seen' }
    }
  );
 
  // Notify all users in this chat
io.to(chatId).emit("messagesSeen", { chatId, seenBy: userId });
});


//online offline 

const onlineUsers = new Map(); // userId => socketId
 
module.exports = {
  addUser(userId, socketId) {
    onlineUsers.set(userId, socketId);
  },
  removeUserBySocket(socketId) {
    for (const [userId, sockId] of onlineUsers.entries()) {
      if (sockId === socketId) {
        onlineUsers.delete(userId);
        return userId;
      }
    }
  },
  getOnlineUsers() {
    return Array.from(onlineUsers.keys());
  },
  getSocketByUser(userId) {
    return onlineUsers.get(userId);
  }
};
 
const { addUser, removeUserBySocket, getOnlineUsers } = require("../utils/onlineUsers");
const User = require("../models/user.model");
 
io.use(authMiddlewareSocket); // already done
 
io.on("connection", async (socket) => {
  const userId = socket.user._id;
 
  //  Mark as online
addUser(userId.toString(), socket.id);
  await User.findByIdAndUpdate(userId, { isOnline: true });
 
  // Notify others
  socket.broadcast.emit("userOnline", { userId });
 
  //  Send full online list to newly joined user
  socket.emit("onlineUsers", getOnlineUsers());
 
  socket.on("disconnect", async () => {
const removedUserId = removeUserBySocket(socket.id);
    if (removedUserId) {
      await User.findByIdAndUpdate(removedUserId, { isOnline: false });
 
      // Notify all users
      socket.broadcast.emit("userOffline", { userId: removedUserId });
    }
  });
});